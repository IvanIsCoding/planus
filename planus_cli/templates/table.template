#[derive(Clone, Debug)]
pub struct {{ info.owned_type }}{
    {% for info in field_infos -%}
        pub {{ info.owned_field_name }}: Option<{{ info.owned_field_type }}>,
    {% endfor %}
}


impl {{info.owned_type}} {
    pub fn create(
        buffer: &mut planus::Buffer,
        {% for info in field_infos -%}
            {%- if info.is_union -%}
                {{info.create_name}}: impl planus::WriteAsOptionalUnion<{{info.create_type}}>,
            {%- else -%}
                {{info.create_name}}: impl planus::WriteAsOptional<{{info.create_type}}>,
            {%- endif -%}
        {% endfor %}
    ) -> planus::Offset<Self> {
        {% for info in field_infos -%}
            let prepared_{{info.create_name}} = {{info.create_name}}.prepare(buffer);
        {% endfor %}

        let mut table_writer = planus::table_writer::TableWriter::<{{(max_vtable_index+2)*2}}, {{max_size-4}}>::new(buffer);

        {% for (f, info) in self.fields() %}
            if prepared_{{info.create_name}}.is_some() {
                {% if info.is_union %}
                    table_writer.calculate_size::<u8>({{2 * (f.vtable_index + 1)}});
                    table_writer.calculate_size::<planus::Offset<()>>({{2 * (f.vtable_index + 2)}});
                {% else %}
                    table_writer.calculate_size::<{{info.create_type}}>({{2 * (f.vtable_index + 1)}});
                {% endif %}
            }
        {% endfor %}
        table_writer.finish_calculating();

        {% if !self.fields.is_empty() %}
        unsafe {
            {% for (f, info) in self.fields_in_alignment_order() %}
                if let Some(prepared_{{info.create_name}}) = prepared_{{info.create_name}} {
                    {% if info.is_union %}
                        table_writer.write({{f.vtable_index+1}}, &prepared_{{info.create_name}}.offset);
                    {% else %}
                        table_writer.write({{f.vtable_index}}, &prepared_{{info.create_name}});
                    {% endif %}
                }
            {% endfor %}
            {% for (f, info) in self.fields_in_alignment_order() %}
                {% if info.is_union %}
                    if let Some(prepared_{{info.create_name}}) = prepared_{{info.create_name}} {
                        table_writer.write({{f.vtable_index}}, &prepared_{{info.create_name}}.tag);
                    }
                {% endif %}
            {% endfor %}
        }
        {% endif %}
        table_writer.finish()
    }
}

impl planus::WriteAs<planus::Offset<{{info.owned_type}}>> for {{info.owned_type}} {
    fn prepare(&self, buffer: &mut planus::Buffer) -> planus::Offset<{{info.owned_type}}> {
        {{info.owned_type}}::create(
            buffer,
        {% for info in field_infos -%}
            {% if info.owned_field_type.starts_with("Box") %}
                self.{{info.owned_field_name}}.as_deref(),
            {% else %}
                &self.{{info.owned_field_name}},
            {% endif %}
        {%- endfor %}
        )
    }
}

impl planus::WriteAsOptional<planus::Offset<{{info.owned_type}}>> for {{info.owned_type}} {
    fn prepare(&self, buffer: &mut planus::Buffer) -> Option<planus::Offset<{{info.owned_type}}>> {
        Some(planus::WriteAs::prepare(self, buffer))
    }
}

#[derive(Copy, Clone)]
pub struct {{info.read_type}}(planus::table_reader::Table<'buf>);

impl<'buf> {{info.read_type}} {
    {% for (f, info) in self.fields() %}
        pub fn {{info.read_name}}(&self) -> planus::Result<Option<{{info.read_type}}>> {
            {% if info.is_union %}
            self.0.access_union({{f.vtable_index}})
            {% else %}
            self.0.access({{f.vtable_index}})
            {% endif %}.map_err(|error_kind| planus::Error {
                source_location: planus::errors::ErrorLocation {
                    type_: "{{name}}".into(),
                    method: "{{info.read_name}}",
                    byte_offset: usize::MAX,
                },
                error_kind,
            })
        }
    {% endfor %}
}

impl<'buf> std::fmt::Debug for {{info.read_type}} {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = f.debug_struct("{{info.owned_type}}");
        {% for info in field_infos %}
            if let Ok(Some({{info.read_name}})) = self.{{info.read_name}}() {
                s.field("{{info.read_name}}", &{{info.read_name}});
            }
        {% endfor %}
        s.finish()
    }
}

impl<'buf> planus::ToOwned for {{info.read_type}} {
    type Value = {{info.owned_type}};

    fn to_owned(&self) -> planus::Result<Self::Value> {
        Ok({{info.owned_type}} {
            {% for info in field_infos -%}
                {{info.owned_field_name}}: {
                    if let Some({{info.read_name}}) = self.{{info.read_name}}()? {
                        {%- if info.owned_field_type.starts_with("Box") -%}
                            Some(Box::new(planus::ToOwned::to_owned(&{{info.read_name}})?))
                        {%- else if info.is_string -%}
                            Some({{info.read_name}}.to_string())
                        {%- else -%}
                            Some(planus::ToOwned::to_owned(&{{info.read_name}})?)
                        {%- endif -%}
                    } else {
                        None
                    }
                },
            {%- endfor %}
        })
    }
}

impl<'buf> planus::TableRead<'buf> for {{info.read_type}} {
    fn from_buffer(buffer: planus::BufferWithStartOffset<'buf>, offset: usize) -> Result<Self, planus::errors::ErrorKind> {
        Ok(Self(planus::table_reader::Table::from_buffer(buffer, offset)?))
    }
}

impl<'buf> planus::VectorRead<'buf> for {{info.read_type}} {
    type Output = planus::Result<{{info.read_type}}>;
    const STRIDE: usize = 4;

    unsafe fn from_buffer(buffer: planus::BufferWithStartOffset<'buf>, offset: usize) -> Self::Output {
        planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| planus::Error {
            source_location: planus::errors::ErrorLocation {
                type_: "[{{info.read_type}}]".into(),
                method: "get",
                byte_offset: usize::MAX,
            },
            error_kind
        })
    }
}

impl planus::VectorWrite<planus::Offset<{{info.owned_type}}>> for {{info.owned_type}} {
    type Value = planus::Offset<{{info.owned_type}}>;
    const STRIDE: usize = 4;
    fn prepare(&self, buffer: &mut planus::Buffer) -> Self::Value {
        planus::WriteAs::prepare(self, buffer)
    }
}