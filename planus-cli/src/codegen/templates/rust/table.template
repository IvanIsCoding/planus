#[derive(Clone, Debug, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct {{ info.owned_name }}{
    {% for field in fields.declaration_order() -%}
        pub {{ field.info.name }}: {{ field.info.owned_type }},
    {%- endfor -%}
}

impl {{info.owned_name}} {
    #[allow(clippy::too_many_arguments)]
    pub fn create(
        builder: &mut planus::Builder,
        {% for field in fields.declaration_order() -%}
            {{ field.info.create_name }}: impl planus::{{ field.info.create_trait }},
        {% endfor %}
    ) -> planus::Offset<Self> {
        {% for field in fields.declaration_order() -%}
            {% match field.info.serialize_default %}
            {% when Some with (serialize_default) %}
            let prepared_{{ field.info.create_name }} = {{ field.info.create_name }}.prepare(builder, {{ serialize_default }});
            {% when None %}
            let prepared_{{ field.info.create_name }} = {{ field.info.create_name }}.prepare(builder);
            {% endmatch %}
        {% endfor %}

        {# TODO: Do not write out values if they are equal to the default value for the field #}
        let mut table_writer = planus::table_writer::TableWriter::<{{(max_vtable_index+2)*2}}, {{max_size-4}}>::new(builder);

        {% for field in fields.declaration_order() %}
            {%- if field.info.read_type.starts_with("Option<") || field.info.serialize_default.is_some() -%}
            if prepared_{{field.info.create_name}}.is_some() {
            {%- endif -%}
                {%- if field.field_type == BackendTableFieldType::UnionValue -%}
                table_writer.calculate_size::<u8>({{2 * (field.vtable_index)}});
                {%- endif -%}
                table_writer.calculate_size::<{{field.info.vtable_type}}>({{2 * (field.vtable_index + 1)}});
            {%- if field.info.read_type.starts_with("Option<") || field.info.serialize_default.is_some() -%}
            }
            {%- endif -%}
        {% endfor %}

        table_writer.finish_calculating();

        {% if !fields.is_empty() %}
        unsafe {
            {% for field in fields.alignment_order() %}
                {%- if field.info.read_type.starts_with("Option<") || field.info.serialize_default.is_some() -%}
                if let Some(prepared_{{field.info.create_name}}) = prepared_{{field.info.create_name}} {
                {%- endif -%}
                    {%- match field.field_type -%}
                    {%- when BackendTableFieldType::UnionKey -%} table_writer.write::<_, _, 1>({{field.vtable_index}}, &prepared_{{field.info.create_name}}.tag);
                    {%- when BackendTableFieldType::UnionValue -%} table_writer.write::<_, _, {{field.info.primitive_size}}>({{field.vtable_index}}, &prepared_{{field.info.create_name}}.offset);
                    {%- when BackendTableFieldType::Other -%} table_writer.write::<_, _, {{field.info.primitive_size}}>({{field.vtable_index}}, &prepared_{{field.info.create_name}});
                    {%- endmatch -%}
                {%- if field.info.read_type.starts_with("Option<") || field.info.serialize_default.is_some() -%}
                }
                {%- endif -%}
            {% endfor %}
        }
        {% endif %}

        table_writer.finish()
    }
}

impl planus::WriteAs<planus::Offset<{{info.owned_name}}>> for {{info.owned_name}} {
    type Prepared = planus::Offset<Self>;

    fn prepare(&self, builder: &mut planus::Builder) -> planus::Offset<{{info.owned_name}}> {
        planus::WriteAsOffset::prepare(self, builder)
    }
}

impl planus::WriteAsOptional<planus::Offset<{{info.owned_name}}>> for {{info.owned_name}} {
    type Prepared = planus::Offset<Self>;

    fn prepare(&self, builder: &mut planus::Builder) -> Option<planus::Offset<{{info.owned_name}}>> {
        Some(planus::WriteAsOffset::prepare(self, builder))
    }
}

impl planus::WriteAsOffset<{{info.owned_name}}> for {{info.owned_name}} {
    fn prepare(&self, builder: &mut planus::Builder) -> planus::Offset<{{info.owned_name}}> {
        {{info.owned_name}}::create(
            builder,
        {% for field in fields.declaration_order() %}
            &self.{{field.info.name}},
        {% endfor %}
        )
    }
}

#[derive(Copy, Clone)]
pub struct {{info.ref_name}}<'a>(planus::table_reader::Table<'a>);

impl<'a> {{info.ref_name}}<'a> {
    {% for field in fields.declaration_order() %}
        pub fn {{field.info.name}}(&self) -> planus::Result<{{field.info.read_type}}> {
            {% if field.info.deserialize_default.is_some() %} Ok( {% endif %}
            {% if field.field_type == BackendTableFieldType::UnionValue %}
              {% if field.info.required %}
              self.0.access_union_required({{field.vtable_index-1}}, "{{info.owned_name}}", "{{field.info.name}}")
              {% else %}
              self.0.access_union({{field.vtable_index-1}}, "{{info.owned_name}}", "{{field.info.name}}")
              {% endif %}
            {% else %}
              {% if field.info.required %}
              self.0.access_required({{field.vtable_index}}, "{{info.owned_name}}", "{{field.info.name}}")
              {% else %}
              self.0.access({{field.vtable_index}}, "{{info.owned_name}}", "{{field.info.name}}")
              {% endif %}
            {% endif %}
            {% match field.info.deserialize_default %}
            {% when Some with (deserialize_default) %}?.unwrap_or({{deserialize_default}}))
            {% when None %}
            {% endmatch %}
        }
    {% endfor %}
}

impl<'a> std::fmt::Debug for {{info.ref_name}}<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("{{info.ref_name}}");
        {% for field in fields.declaration_order() -%}
            {%- if field.info.read_type.starts_with("Option<") -%}
            if let Ok(Some({{field.info.name}})) = self.{{field.info.name}}() {
                f.field("{{field.info.name}}", &{{field.info.name}});
            }
            {%- else -%}
            if let Ok({{field.info.name}}) = self.{{field.info.name}}() {
                f.field("{{field.info.name}}", &{{field.info.name}});
            }
            {%- endif -%}
        {%- endfor %}
        f.finish()
    }
}

impl<'a> planus::ToOwned for {{info.ref_name}}<'a> {
    type Value = {{info.owned_name}};

    fn to_owned(self) -> planus::Result<Self::Value> {
        Ok({{info.owned_name}} {
            {% for field in fields.declaration_order() -%}
                {{field.info.name}}:
                    {%- if field.info.owned_type.starts_with("Option<Box<") -%}
                    if let Some({{field.info.name}}) = self.{{field.info.name}}()? {
                        Some(Box::new(planus::ToOwned::to_owned({{field.info.name}})?))
                    } else {
                        None
                    }
                    {%- elseif field.info.owned_type.starts_with("Option<") -%}
                    if let Some({{field.info.name}}) = self.{{field.info.name}}()? {
                        Some(planus::ToOwned::to_owned({{field.info.name}})?)
                    } else {
                        None
                    }
                    {%- elseif field.info.owned_type.starts_with("Box<") -%}
                        Box::new(planus::ToOwned::to_owned(self.{{field.info.name}}()?)?)
                    {%- else -%}
                    planus::ToOwned::to_owned(self.{{field.info.name}}()?)?
                    {%- endif -%}
                ,
            {%- endfor %}
        })
    }
}

impl<'a> planus::TableRead<'a> for {{info.ref_name}}<'a> {
    fn from_buffer(buffer: planus::SliceWithStartOffset<'a>, offset: usize) -> std::result::Result<Self, planus::errors::ErrorKind> {
        Ok(Self(planus::table_reader::Table::from_buffer(buffer, offset)?))
    }
}

impl<'a> planus::VectorRead<'a> for {{info.owned_name}} {
    type Output = planus::Result<{{info.ref_name}}<'a>>;
    const STRIDE: usize = 4;

    unsafe fn from_buffer(buffer: planus::SliceWithStartOffset<'a>, offset: usize) -> Self::Output {
        planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| error_kind.with_error_location(
            "[{{info.ref_name}}]",
            "get",
            buffer.offset_from_start,
        ))
    }
}

impl planus::VectorWrite<planus::Offset<{{info.owned_name}}>> for {{info.owned_name}} {
    type Value = planus::Offset<{{info.owned_name}}>;
    const STRIDE: usize = 4;
    fn prepare(&self, builder: &mut planus::Builder) -> Self::Value {
        planus::WriteAs::prepare(self, builder)
    }

    #[inline]
    unsafe fn write_values(
        values: &[planus::Offset<{{info.owned_name}}>],
        bytes: *mut std::mem::MaybeUninit<u8>,
        buffer_position: u32,
    ) {
        let bytes = bytes as *mut [std::mem::MaybeUninit<u8>; 4];
        for (i, v) in values.iter().enumerate() {
            planus::WriteAsPrimitive::write(
                v,
                planus::Cursor::new(&mut *bytes.add(i)),
                buffer_position - (Self::STRIDE * i) as u32,
            );
        }
    }
}

impl<'a> planus::ReadAsRoot<'a> for {{info.ref_name}}<'a> {
    fn read_as_root(slice: &'a [u8]) -> planus::Result<Self> {
        planus::TableRead::from_buffer(planus::SliceWithStartOffset {
            buffer: slice,
            offset_from_start: 0,
        }, 0).map_err(|error_kind| error_kind.with_error_location(
            "[{{info.ref_name}}]",
            "read_as_root",
            0,
        ))
    }
}